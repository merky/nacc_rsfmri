#!/bin/bash
# author: mhollen@nmr.mgh.harvard.edu

set -e

# user settings
SKIP=4 # drop first N frames
FWHM=6 # smoothing in mm TODO: change back to 4
BPSS_LO=0.009
BPSS_HI=0.08
TR=5.0
SLICE_ORDER=odd # odd/up/down
ORIENT=RPI # to match template
PROCESS_DIR=restproc
DO_NONLINEAR_REG=false

# not enough args
if [[ $# -lt 3 ]]; then
    echo "usage: $(basename $0) subject_dir anat.nii rest1.nii [rest2.nii...]"
    exit 0;
fi

# inputs
SUBJECT_DIR=$1
shift
ANAT=$1
shift
BOLDS=($@)
BOLDN=$#

echo "You have $BOLDN BOLD runs..."
echo "They are: ${BOLDS[@]}"

# settings

# script directory
script_dir=$(echo $(cd $(dirname $(readlink -f $0)); pwd) )
templates_dir=$script_dir/templates

# standard space
STANDARD=$templates_dir/MNI152_T1_2mm
STANDARD_BRAIN=$templates_dir/MNI152_T1_2mm_brain
STANDARD_MASK=$templates_dir/MNI152_T1_2mm_brain_mask.nii.gz
STANDARD_MASK_DIL=$templates_dir/MNI152_T1_2mm_brain_mask_dil.nii.gz

# masks for extracting nuisance signals
MASK_VENTRICLES=$templates_dir/avg152T1_ventricles_MNI.nii.gz
MASK_WM=$templates_dir/avg152T1_WM_MNI.nii.gz
#MASK_WHOLEBRAIN=$STANDARD_MASK
MASK_WHOLEBRAIN=$templates_dir/avg152T1_brain_MNI.nii.gz

# config
FLIRT_CONF=$FSL_DIR/etc/flirtsch/sch3Dtrans_3dof
FNIRT_CONF=$FSLDIR/etc/flirtsch/T1_2_MNI152_2mm.cnf

# output dir
d=$SUBJECT_DIR/$PROCESS_DIR

# create output dirs
mkdir -p $d/{reg,nuisance,seg}

# detect TR from file (in msec)
function get_tr () {
    tr=$(mri_info            $1 |
                        grep TR |
          awk '{print $2;exit}' |
                   cut -d. -f1  )

    # can't modify 0
    [[ $tr -eq 0 ]] && echo 0;

    # otherwise, return tr in seconds
    echo $(echo "scale=2;$tr/1000" | bc)
}


# initialize anatomy volume 
run_anat_init () {
    tmpfile=`mktemp --suffix=.nii.gz`
    scp $ANAT $tmpfile
    # deoblique
    3drefit -deoblique $tmpfile

    # copy data
    echo " * Copying anatomical data (reorienting to LAS)..."
    3dresample -orient $ORIENT -inset $tmpfile -prefix $d/anat.nii.gz

    #skull strip anat
    echo " * Skull stripping anat"
    bet $d/anat $d/anat_brain -R -g -.4 -f .35
}

# register anatomy to standard
run_anat_reg () {
    standard=$(mktemp --suffix .nii.gz)

    # make copy of template volume (ANTs requires)
    cp $STANDARD_BRAIN.nii.gz $standard

    # normalize anat -> template
    echo " * Normalizing anat -> standard"
    antsIntroduction.sh -d 3 \
                        -i $d/anat_brain.nii.gz \
                        -r $standard \
                        -o $d/anat_brain_atl_
}


#############################################
# copy data, reorient, slice time correction
#############################################
#  input: <filebase> <input>
# output: <filebase>_reorient_skip_tc
#############################################
run_func_init () {
    inputvol=$1
    fpath=$2

    # functional inputs
    echo " * Copying functional image to dir"
    scp $inputvol ${fpath}.nii.gz

    # get TR
    TR=$(get_tr $fpath.nii.gz)

    if [[ "$TR" == "0" ]]; then
        echo "TR=$TR"
        echo "Error: TR could not be determined from nifti input"
        exit
    fi

    # deoblique
    3drefit -deoblique ${fpath}.nii.gz

    # reorient
    echo " * Reorienting to $ORIENT"
    3dresample -orient $ORIENT \
                -inset ${fpath}.nii.gz \
               -prefix ${fpath}_reorient.nii.gz

    # remove first N frames
    echo " * Removing first $SKIP frames from functional"
    numvols=`echo "$(fslnvols ${fpath}_reorient) - $SKIP" | bc`
    fslroi ${fpath}_reorient ${fpath}_reorient_skip $SKIP $numvols

    # slice time correction? (need to find scan timing)
    echo " * Performing slice time correction"
    slicetimer -i ${fpath}_reorient_skip \
               -o ${fpath}_reorient_skip_tc \
               -r $TR \
               --$SLICE_ORDER
}


#############################################
# motion correction
#############################################
#  input: <filebase> NAME
# output: <filebase>_mc
#############################################
run_func_motion () {
    fpath=$1
    fbase=$2

    echo " * $fbase: Motion correction"
    mcflirt -in $fpath \
            -out ${fpath}_mc \
            -plots \
            -report

    # plot motion
    echo " * $fbase: Plotting motion parameters"

    # rotations
    fsl_tsplot -i ${fpath}_mc.par \
               -t 'MCFLIRT estimated rotations (radians)' \
               -u 1 --start=1 --finish=3 \
               -a x,y,z -w 640 -h 144 \
               -o ${fpath}_mc_rot.png

    # translations
    fsl_tsplot -i ${fpath}_mc.par \
               -t 'MCFLIRT estimated translations (mm)' \
               -u 1 --start=4 --finish=6 \
               -a x,y,z -w 640 -h 144 \
               -o ${fpath}_mc_trans.png

    # save motion regressors as separate files 
    for x in $(seq 1 6); do
        cat ${fpath}_mc.par |
        awk '{print $'${x}'}' > $d/nuisance/${fbase}.regressor.motion${x}.txt
    done
}


#############################################
# registration/normalization
#############################################
#  input: <filebase>
# output: <filebase>[_brain]_atl_affine
#############################################
run_func_reg_and_normalize () {
    fpath=$1

    # coregister func -> anat (using ANTs)
    echo " * coregistration "
    rsfmri_coreg 3 \
                 $d/anat_brain.nii.gz \
                 ${fpath}_mean_brain.nii.gz \
                 ${fpath}_mean_brain_2anat_

    # transform func -> template
    echo " * normalizing anat -> standard "
    WarpTimeSeriesImageMultiTransform 4 \
                        ${fpath}_brain.nii.gz \
                        ${fpath}_brain_atl_affine.nii.gz \
                        -R $STANDARD_BRAIN.nii.gz \
                        $d/anat_brain_atl_Affine.txt \
                        ${fpath}_mean_brain_2anat_Affine.txt
}


#############################################
# skullstrip (and functional mean)
#############################################
#  input: <filebase> NAME
# output: <filebase>_brain
#############################################
run_func_skullstrip() {
    fpath=$1
    fbase=$2

    # create mean of functional
    fslmaths        ${fpath} \
             -Tmean ${fpath}_mean

    echo " * $fbase: Skull stripping mean image"
    # skull strip it
    bet      ${fpath}_mean \
             ${fpath}_mean_brain \
             -R -f 0.3 -m

    echo " * $fbase: Apply skull strip mask to 4d functional"
    # apply skull strip to 4d functional
    fslmaths      ${fpath} \
             -mas ${fpath}_mean_brain_mask \
                  ${fpath}_brain

    echo " * $fbase: Use 2nd/98th percentiles of 4d image to improve brain mask"

    # determine threshold
    p2=$(  fslstats ${fpath}_brain -p 2)
    p98=$( fslstats ${fpath}_brain -p 98)
    thr=$( echo "scale=5; $p2 + ($p98 -$p2)/10" | bc)

    # create mask below threshold
    fslmaths       ${fpath}_brain \
             -thr  $thr \
             -Tmin \
             -bin  ${fpath}_brain_percmask \
             -odt  char

    # dilate mask (redue likelihood of removing brain voxels)
    fslmaths       ${fpath}_brain_percmask \
             -dilF ${fpath}_brain_percmask_dil

    echo " * $fbase: Applying improved brain mask to 4d image"
    # apply dilated mask to 4d image
    fslmaths      ${fpath} \
             -mas ${fpath}_brain_percmask_dil \
                  ${fpath}_brain

}


#############################################
# smoothing, nuisance regression
#############################################
#  input: <filebase> NAME
# output: <filebase>_fwhm#_bpss_resid
run_fcpreproc () {
    fpath=$1
    fbase=$2

    # compute the following for BOTH linear and nonlinear by calling:
    #  run_fcpreproc warp
    #  run_fcpreproc affine

    # guassian smooth
    echo " * $fbase: Smoothing (${FWHM}mm) functional images"
    3dmerge -1blur_fwhm $FWHM \
            -doall \
            -prefix ${fpath}_fwhm${FWHM}.nii.gz \
                    ${fpath}.nii.gz

    # grand mean scaling
    fslmaths      ${fpath}_fwhm${FWHM} \
             -ing 10000 \
                  ${fpath}_fwhm${FWHM}_gms \
             -odt float

    # extract mean wm time series
    echo " * $fbase: Extracting mean white-matter time course signal"
    fslmeants -i ${fpath}_fwhm${FWHM}_gms.nii.gz \
              -m $MASK_WM \
              -o $d/nuisance/${fbase}.regressor.wm.txt

    # extract mean whole brain time series
    echo " * $fbase: Extracting mean whole-brain time course signal"
    fslmeants -i ${fpath}_fwhm${FWHM}_gms.nii.gz \
              -m $MASK_WHOLEBRAIN \
              -o $d/nuisance/${fbase}.regressor.wholebrain.txt

    # extract mean ventricle time series
    echo " * $fbase: Extracting mean ventricles time course signal"
    fslmeants -i ${fpath}_fwhm${FWHM}_gms.nii.gz \
              -m $MASK_VENTRICLES \
              -o $d/nuisance/${fbase}.regressor.ventricles.txt


    # calculate mean signal derivatives (backwards diff)
    1d_tool.py -infile $d/nuisance/${fbase}.regressor.ventricles.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.ventricles.deriv.txt

    1d_tool.py -infile $d/nuisance/${fbase}.regressor.wholebrain.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.wholebrain.deriv.txt

    1d_tool.py -infile $d/nuisance/${fbase}.regressor.wm.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.wm.deriv.txt

    # calculate motion derivatives (backwards diff)
    1d_tool.py -infile $d/nuisance/${fbase}.regressor.motion1.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.motion1.deriv.txt

    1d_tool.py -infile $d/nuisance/${fbase}.regressor.motion2.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.motion2.deriv.txt

    1d_tool.py -infile $d/nuisance/${fbase}.regressor.motion3.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.motion3.deriv.txt

    1d_tool.py -infile $d/nuisance/${fbase}.regressor.motion4.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.motion4.deriv.txt

    1d_tool.py -infile $d/nuisance/${fbase}.regressor.motion5.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.motion5.deriv.txt

    1d_tool.py -infile $d/nuisance/${fbase}.regressor.motion6.txt \
               -backward_diff \
               -write $d/nuisance/${fbase}.regressor.motion6.deriv.txt


    # bandpass
    echo " * $fbase: Applying bandpass filter (low: $BPSS_LO, high: $BPSS_HI)"
    echo " *    while regressing out nuisance signals (motion, wm, whole brain, csf)"
    echo " *    as well as constant, linear, and quadratic trends"
    3dBandpass -prefix ${fpath}_fwhm${FWHM}_bpss_resid.nii.gz \
               -ort    $d/nuisance/${fbase}.regressor.wm.txt \
               -ort    $d/nuisance/${fbase}.regressor.wholebrain.txt \
               -ort    $d/nuisance/${fbase}.regressor.ventricles.txt \
               -ort    $d/nuisance/${fbase}.regressor.wm.deriv.txt \
               -ort    $d/nuisance/${fbase}.regressor.wholebrain.deriv.txt \
               -ort    $d/nuisance/${fbase}.regressor.ventricles.deriv.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion1.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion2.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion3.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion4.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion5.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion6.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion1.deriv.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion2.deriv.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion3.deriv.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion4.deriv.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion5.deriv.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion6.deriv.txt \
               -mask   $STANDARD_MASK \
                       $BPSS_LO $BPSS_HI \
                       ${fpath}_fwhm${FWHM}_gms.nii.gz

}

###############################################
# Run preprocessing steps
###############################################
# we will fork some steps to speed things up
#

# init
run_anat_init
# anat registration
run_anat_reg


runs_lin=""
runs_nlin=""

n=1
for bold in ${BOLDS[@]}; do
    name="rest$(printf '%02d' $n)"

    (

    # initialize <input vol> <input base>
    run_func_init $bold $d/$name

    # motion correction <input base> <name>
    run_func_motion $d/${name}_reorient_skip_tc $name

    # func skullstrip (and create mean)
    run_func_skullstrip $d/${name}_reorient_skip_tc_mc $name

    # func registration <input base> <name>
    run_func_reg_and_normalize $d/${name}_reorient_skip_tc_mc

    # smoothing, bandpass <input base> <name>
    if $DO_NONLINEAR_REG; then 
        echo "WARNING: non-linear disabled"
        #run_fcpreproc $d/${name}_reorient_skip_tc_mc_brain_atl_warp $name &
    fi
    run_fcpreproc $d/${name}_reorient_skip_tc_mc_brain_atl_affine $name &

    wait # wait for sub-threads (linear/nonlinear reg)
    exit

    ) &

    runs_lin="$runs_lin $d/${name}_reorient_skip_tc_mc_brain_atl_affine_fwhm${FWHM}_bpss_resid.nii.gz"
    runs_nlin="$runs_nlin $d/${name}_reorient_skip_tc_mc_brain_atl_warp_fwhm${FWHM}_bpss_resid.nii.gz"

    n=$((n+1))
done

# wait for run threads to finish
wait

# combine runs into a single, concatenated 4d file
if [[ $BOLDN -gt 1 ]]; then
    fslmerge -t $d/rest_fwhm$FWHM.nii.gz $runs_lin
else
    ln -s -T $runs_lin $d/rest_fwhm$FWHM.nii.gz
fi

exit

