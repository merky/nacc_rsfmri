#!/bin/bash
# author: mhollen@nmr.mgh.harvard.edu

set -e

# user settings
SKIP=4 # drop first N frames
FWHM=4 # smoothing in mm
BPSS_LO=0.009
BPSS_HI=0.08 
TR=5.0
SLICE_ORDER=odd # odd/up/down
ORIENT=RPI # to match template
PROCESS_DIR=restproc
DO_NONLINEAR_REG=false

# not enough args
if [[ $# -lt 3 ]]; then
    echo "usage: $(basename $0) subject_dir anat.nii rest1.nii [rest2.nii...]"
    exit 0;
fi

# inputs
SUBJECT_DIR=$1
shift
ANAT=$1
shift
BOLDS=($@)
BOLDN=$#

echo "You have $BOLDN BOLD runs..."
echo "They are: ${BOLDS[@]}"

# settings

# script directory
script_dir=$(echo $(cd $(dirname $(readlink -f $0)); pwd) )
templates_dir=$script_dir/templates

# standard space
STANDARD=$templates_dir/MNI152_T1_2mm
STANDARD_BRAIN=$templates_dir/MNI152_T1_2mm_brain
STANDARD_MASK=$templates_dir/MNI152_T1_2mm_brain_mask.nii.gz
STANDARD_MASK_DIL=$templates_dir/MNI152_T1_2mm_brain_mask_dil.nii.gz

# masks for extracting nuisance signals
MASK_VENTRICLES=$templates_dir/avg152T1_ventricles_MNI.nii.gz
MASK_WM=$templates_dir/avg152T1_WM_MNI.nii.gz
MASK_WHOLEBRAIN=$STANDARD_MASK

# config
FLIRT_CONF=$FSL_DIR/etc/flirtsch/sch3Dtrans_3dof
FNIRT_CONF=$FSLDIR/etc/flirtsch/T1_2_MNI152_2mm.cnf

# output dir
d=$SUBJECT_DIR/$PROCESS_DIR

# create output dirs
mkdir -p $d/{reg,nuisance,seg}

# detect TR from file (in msec)
function get_tr () {
    tr=$(mri_info            $1 |
                        grep TR |
          awk '{print $2;exit}' |
                   cut -d. -f1  )

    # can't modify 0
    [[ $tr -eq 0 ]] && echo 0;

    # otherwise, return tr in seconds
    echo $(echo "scale=2;$tr/1000" | bc)
}

# initialize anatomy volume
run_anat_init () {
    tmpfile=`mktemp --suffix=.nii.gz`
    scp $ANAT $tmpfile
    # deoblique
    3drefit -deoblique $tmpfile

    # copy data
    echo " * Copying anatomical data (reorienting to LAS)..."
    3dresample -orient $ORIENT -inset $tmpfile -prefix $d/anat.nii.gz

    #skull strip anat
    echo " * Skull stripping anat"
    bet $d/anat $d/anat_brain -R -g -.4 -f .35
}

# register anatomy to standard
run_anat_reg () {
    #############################################
    # anatomical registration to standard
    #############################################

    # register anat brain to standard space
    echo " * Linear transform: anat (brain) -> standard"
    flirt -in   $d/anat_brain \
          -out  $d/anat_atl_linear \
          -ref  $STANDARD_BRAIN \
          -cost corratio \
          -dof  12 \
          -searchrx -90 90 \
          -searchry -90 90 \
          -searchrz -90 90 \
          -interp trilinear \
          -omat $d/reg/anat2standard.affine.mat

    if $DO_NONLINEAR_REG; then
        # nonlinear warp, use non skull-stripped anat
        echo " * Non-linear warp: anat -> standard"
        fnirt  --ref=$STANDARD \
               --refmask=$STANDARD_MASK \
               --in=$d/anat \
               --iout=$d/anat_atl_warp \
               --aff=$d/reg/anat2standard.affine.mat \
               --cout=$d/reg/anat2standard.warp.coef \
               --interp=spline \
               --config=$FNIRT_CONF
    fi

    echo " * Segmenting T1 (brain)"
    fast -o $d/seg/anat_brain_fast $d/anat_brain

    echo " * Creating binarized white matter mask"
    fslmaths $d/seg/anat_brain_fast_pve_2 \
             -thr 0.5 -bin $d/seg/anat_brain_wmseg
}

#############################################
# copy data, reorient, slice time correction
#############################################
#  input: <filebase> <input>
# output: <filebase>_reorient_skip_tc
#############################################
run_func_init () {
    inputvol=$1
    fpath=$2

    # functional inputs
    echo " * Copying functional image to dir"
    scp $inputvol ${fpath}.nii.gz

    # get TR
    TR=$(get_tr $fpath.nii.gz)

    if [[ "$TR" == "0" ]]; then
        echo "TR=$TR"
        echo "Error: TR could not be determined from nifti input"
        exit
    fi

    # deoblique
    3drefit -deoblique ${fpath}.nii.gz

    # reorient
    echo " * Reorienting to $ORIENT"
    3dresample -orient $ORIENT \
                -inset ${fpath}.nii.gz \
               -prefix ${fpath}_reorient.nii.gz

    # remove first N frames
    echo " * Removing first $SKIP frames from functional"
    numvols=`echo "$(fslnvols ${fpath}_reorient) - $SKIP" | bc`
    fslroi ${fpath}_reorient ${fpath}_reorient_skip $SKIP $numvols

    # slice time correction? (need to find scan timing)
    echo " * Performing slice time correction"
    slicetimer -i ${fpath}_reorient_skip \
               -o ${fpath}_reorient_skip_tc \
               -r $TR \
               --$SLICE_ORDER
}


#############################################
# motion correction
#############################################
#  input: <filebase> NAME
# output: <filebase>_mc
#############################################
run_func_motion () {
    fpath=$1
    fbase=$2

    echo " * $fbase: Motion correction"
    mcflirt -in $fpath \
            -out ${fpath}_mc \
            -plots \
            -report

    # plot motion
    echo " * $fbase: Plotting motion parameters"

    # rotations
    fsl_tsplot -i ${fpath}_mc.par \
               -t 'MCFLIRT estimated rotations (radians)' \
               -u 1 --start=1 --finish=3 \
               -a x,y,z -w 640 -h 144 \
               -o ${fpath}_mc_rot.png

    # translations
    fsl_tsplot -i ${fpath}_mc.par \
               -t 'MCFLIRT estimated translations (mm)' \
               -u 1 --start=4 --finish=6 \
               -a x,y,z -w 640 -h 144 \
               -o ${fpath}_mc_trans.png

    # save motion regressors as separate files 
    for x in $(seq 1 6); do
        cat ${fpath}_mc.par |
        awk '{print $'${x}'}' > $d/nuisance/${fbase}.regressor.motion${x}.txt
    done
}


#############################################
# registration/normalization
#############################################
#  input: <filebase> NAME
# output: <filebase>_brain_atl_affine
#############################################
run_func_reg() {
    fpath=$1
    fbase=$2

    echo " * $fbase: Creating mean functional image"
    # create mean functional image
    fslmaths        $fpath \
             -Tmean ${fpath}_mean

    echo " * $fbase: Skull stripping mean image"
    # skull strip it
    bet      ${fpath}_mean \
             ${fpath}_mean_brain \
             -R -f 0.3 -m

    echo " * $fbase: Apply skull strip mask to 4d functional"
    # apply skull strip to 4d functional
    fslmaths      ${fpath} \
             -mas ${fpath}_mean_brain_mask \
                  ${fpath}_brain

    echo " * $fbase: Use 2nd/98th percentiles of 4d image to improve brain mask"

    # determine threshold
    p2=$(  fslstats ${fpath}_brain -p 2)
    p98=$( fslstats ${fpath}_brain -p 98)
    thr=$( echo "scale=5; $p2 + ($p98 -$p2)/10" | bc)

    # create mask below threshold
    fslmaths       ${fpath}_brain \
             -thr  $thr \
             -Tmin \
             -bin  ${fpath}_brain_percmask \
             -odt  char

    # dilate mask (redue likelihood of removing brain voxels)
    fslmaths       ${fpath}_brain_percmask \
             -dilF ${fpath}_brain_percmask_dil

    echo " * $fbase: Applying improved brain mask to 4d image"
    # apply dilated mask to 4d image
    fslmaths      ${fpath} \
             -mas ${fpath}_brain_percmask_dil \
                  ${fpath}_brain

    echo " * $fbase: Initial transform estimate, func (mean brain) -> anat"
    flirt -in   ${fpath}_mean_brain \
          -ref  $d/anat_brain \
          -out  $d/reg/${fbase}.func2anat.init \
          -omat $d/reg/${fbase}.func2anat.init.mat \
          -dof  6

    echo " * $fbase: Boundary based registration, func (brain) -> anat"
    flirt -in       ${fpath}_brain \
          -ref      $d/anat_brain \
          -out      $d/reg/${fbase}.func2anat \
          -omat     $d/reg/${fbase}.func2anat.mat \
          -wmseg    $d/seg/anat_brain_wmseg \
          -cost     bbr \
          -init     $d/reg/${fbase}.func2anat.init.mat \
          -dof      6 \
          -schedule ${FSLDIR}/etc/flirtsch/bbr.sch


    if $DO_NONLINEAR_REG; then
        echo " * $fbase: Warping, func (mean mask) -> standard"
        applywarp   --ref=$STANDARD \
                     --in=${fpath}_mean_brain_mask \
                    --out=${fpath}_mean_brain_mask_atl \
                 --premat=$d/reg/${fbase}.func2anat.mat \
                   --warp=$d/reg/anat2standard.warp.coef \
                 --interp=nn \
                   --mask=$STANDARD_MASK_DIL

        echo " * $fbase: Warping, func (4d) -> standard"
        applywarp   --ref=$STANDARD \
                     --in=${fpath}_brain \
                    --out=${fpath}_brain_atl_warp \
                 --premat=$d/reg/${fbase}.func2anat.mat \
                   --warp=$d/reg/anat2standard.warp.coef \
                 --interp=spline \
                   --mask=${fpath}_mean_brain_mask_atl

        echo " * $fbase: Warping, func (mean) -> standard, for qc"
        applywarp   --ref=$STANDARD \
                     --in=${fpath}_mean_brain \
                    --out=${fpath}_mean_brain_atl_warp \
                 --premat=$d/reg/${fbase}.func2anat.mat \
                   --warp=$d/reg/anat2standard.warp.coef \
                 --interp=spline \
                   --mask=${fpath}_mean_brain_mask_atl
    fi

    echo " * $fbase: Concatenating and inversing xfm matrices"
    # concatenate func -> anat -> standard linear transforms
    convert_xfm -omat   $d/reg/${fbase}.func2standard.mat \
                -concat $d/reg/anat2standard.affine.mat \
                        $d/reg/${fbase}.func2anat.mat

    # make inverse matrices
    convert_xfm -omat    $d/reg/${fbase}.standard2func.mat \
                -inverse $d/reg/${fbase}.func2standard.mat
    convert_xfm -omat    $d/reg/${fbase}.anat2func.mat \
                -inverse $d/reg/${fbase}.func2anat.mat
    convert_xfm -omat    $d/reg/standard2anat.affine.mat \
                -inverse $d/reg/anat2standard.affine.mat

    # normalize rest using linear transform
    echo " * $fbase: Applying linear transforms, func (4d) -> standard"
    flirt -in       ${fpath}_brain \
          -out      ${fpath}_brain_atl_affine \
          -ref      $STANDARD_BRAIN \
          -applyxfm \
          -init     $d/reg/${fbase}.func2standard.mat \
          -interp   trilinear

}


#############################################
# smoothing, nuisance regression
#############################################
#  input: <filebase> NAME
# output: <filebase>_fwhm#_bpss_resid
run_fcpreproc () {
    fpath=$1
    fbase=$2

    # compute the following for BOTH linear and nonlinear by calling:
    #  run_fcpreproc warp
    #  run_fcpreproc affine

    # guassian smooth
    echo " * $fbase: Smoothing (${FWHM}mm) functional images"
    3dmerge -1blur_fwhm $FWHM \
            -doall \
            -prefix ${fpath}_fwhm${FWHM}.nii.gz \
                    ${fpath}.nii.gz

    # grand mean scaling
    fslmaths      ${fpath}_fwhm${FWHM} \
             -ing 10000 \
                  ${fpath}_fwhm${FWHM}_gms \
             -odt float

    # extract mean wm time series
    echo " * $fbase: Extracting mean white-matter time course signal"
    fslmeants -i ${fpath}_fwhm${FWHM}_gms.nii.gz \
              -m $MASK_WM \
              -o $d/nuisance/${fbase}.regressor.wm.txt

    # extract mean whole brain time series
    echo " * $fbase: Extracting mean whole-brain time course signal"
    fslmeants -i ${fpath}_fwhm${FWHM}_gms.nii.gz \
              -m $MASK_WHOLEBRAIN \
              -o $d/nuisance/${fbase}.regressor.wholebrain.txt

    # extract mean ventricle time series
    echo " * $fbase: Extracting mean ventricles time course signal"
    fslmeants -i ${fpath}_fwhm${FWHM}_gms.nii.gz \
              -m $MASK_VENTRICLES \
              -o $d/nuisance/${fbase}.regressor.ventricles.txt

    # bandpass
    echo " * $fbase: Applying bandpass filter (low: $BPSS_LO, high: $BPSS_HI)"
    echo " *    while regressing out nuisance signals (motion, wm, whole brain, csf)"
    echo " *    as well as constant, linear, and quadratic trends"
    3dBandpass -prefix ${fpath}_fwhm${FWHM}_bpss_resid.nii.gz \
               -ort    $d/nuisance/${fbase}.regressor.wm.txt \
               -ort    $d/nuisance/${fbase}.regressor.wholebrain.txt \
               -ort    $d/nuisance/${fbase}.regressor.ventricles.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion1.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion2.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion3.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion4.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion5.txt \
               -ort    $d/nuisance/${fbase}.regressor.motion6.txt \
               -mask   $MASK_WHOLEBRAIN \
                       $BPSS_LO $BPSS_HI \
                       ${fpath}_fwhm${FWHM}_gms.nii.gz

    ln -s -T ${fpath}_fwhm${FWHM}_bpss_resid.nii.gz $SUBJECT_DIR/$fbase.nii.gz

}

###############################################
# Run preprocessing steps
###############################################
# we will fork some steps to speed things up
#

# init
run_anat_init
# anat registration
run_anat_reg


runs_lin=""
runs_nlin=""

n=1
for bold in ${BOLDS[@]}; do
    name="rest$(printf '%02d' $n)"

    (

    # initialize <input vol> <input base>
    run_func_init $bold $d/$name

    # motion correction <input base> <name>
    run_func_motion $d/${name}_reorient_skip_tc $name

    # func registration <input base> <name>
    run_func_reg $d/${name}_reorient_skip_tc_mc $name

    # smoothing, bandpass <input base> <name>
    if $DO_NONLINEAR_REG; then 
        run_fcpreproc $d/${name}_reorient_skip_tc_mc_brain_atl_warp &
    fi
    run_fcpreproc $d/${name}_reorient_skip_tc_mc_brain_atl_affine $name &

    wait # wait for sub-threads (linear/nonlinear reg)
    exit

    ) &

    runs_lin="$runs_lin $d/${name}_reorient_skip_tc_mc_brain_atl_affine_fwhm${FWHM}_bpss_resid.nii.gz"
    runs_nlin="$runs_nlin $d/${name}_reorient_skip_tc_mc_brain_atl_warp_fwhm${FWHM}_bpss_resid.nii.gz"

    n=$((n+1))
done

# wait for run threads to finish
wait

# combine runs into a single, concatenated 4d file
if [[ $BOLDN -gt 1 ]]; then
    fslmerge -t $d/rest_fwhm$FWHM.nii.gz $runs_lin
else
    ln -s -T $runs_lin $d/rest_fwhm$FWHM.nii.gz
fi


